generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

/// Canal de conteúdo (ex: The Gap Files, Canal X) — entidade raiz multi-canal
model Channel {
  id                   String    @id @default(uuid())
  name                 String    @db.VarChar(100)
  handle               String    @unique @db.VarChar(50)
  description          String?
  platform             String?   @db.VarChar(50)
  logoBase64           String? /// Logo do canal em base64
  logoMimeType         String?   @db.VarChar(50)
  defaultVisualStyleId String?   @db.VarChar(50) /// slug → constant (visual-styles.ts)
  defaultScriptStyleId String?   @db.VarChar(50) /// slug → constant (script-styles.ts)
  defaultSeedId        String?
  isActive             Boolean   @default(true)
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt
  dossiers             Dossier[]
  defaultSeed          Seed?     @relation("ChannelDefaultSeed", fields: [defaultSeedId], references: [id], onDelete: SetNull)

  @@map("channels")
}

/// Dossiê - centro do sistema, contém todos materiais de research e pode gerar múltiplos outputs
/// Fontes são gerenciadas exclusivamente via DossierSource (arquitetura flat/democratizada)
model Dossier {
  id                     String             @id @default(uuid())
  title                  String             @db.VarChar(255)
  theme                  String
  researchData           Json?
  /// Brief persistido para uso em TEASERS (gateway/deep-dive/hook-only)
  briefBundleV1          Json?
  /// Hash determinístico do dossiê canônico usado para invalidar o brief
  briefBundleV1Hash      String?            @db.VarChar(64)
  /// Última atualização do brief persistido
  briefBundleV1UpdatedAt DateTime?
  /// Brief persistido para uso em EPISÓDIOS COMPLETOS (EP1/EP2/EP3)
  episodeBriefBundleV1          Json?
  /// Hash determinístico do dossiê canônico (invalida brief quando dossier muda)
  episodeBriefBundleV1Hash      String?            @db.VarChar(64)
  /// Última atualização do episode brief persistido
  episodeBriefBundleV1UpdatedAt DateTime?
  /// Prosa narrativa por episódio gerada pelo Escritor Chefe (substitui episode brief)
  escritorChefeBundleV1          Json?
  /// Hash determinístico do dossiê canônico (invalida prosa quando dossier muda)
  escritorChefeBundleV1Hash      String?            @db.VarChar(64)
  /// Última atualização da prosa do Escritor Chefe
  escritorChefeBundleV1UpdatedAt DateTime?
  tags                   String[]
  isProcessed            Boolean            @default(false)
  visualIdentityContext  String?            @db.VarChar(500) // Contexto visual do dossier
  researchPrompt         String?            @db.Text // Prompt gerado pelo Investigador para Gemini Deep Research
  preferredVisualStyleId String?
  preferredSeedId        String?
  channelId              String? /// FK → Channel (nullable para migração gradual)
  createdAt              DateTime           @default(now())
  updatedAt              DateTime           @updatedAt
  images                 DossierImage[]
  notes                  DossierNote[]
  persons                DossierPerson[]
  sources                DossierSource[]
  outputs                Output[]
  costLogs               CostLog[]
  monetizationPlans      MonetizationPlan[]
  seedSamples            SeedSample[]       @relation("DossierSeedSamples")
  preferredSeed          Seed?              @relation("DossierPreferredSeed", fields: [preferredSeedId], references: [id], onDelete: SetNull)
  channel                Channel?           @relation(fields: [channelId], references: [id], onDelete: SetNull)

  @@index([createdAt])
  @@index([isProcessed])
  @@index([channelId])
  @@map("dossiers")
}

/// Fonte do dossiê (todas as fontes são tratadas igualmente — arquitetura flat/democratizada)
/// sourceType indica a natureza: 'document' (documento primário migrado), 'url', 'text', 'pdf'
/// weight permite priorização opcional (padrão 1.0 = todas iguais)
model DossierSource {
  id         String   @id @default(uuid())
  dossierId  String
  title      String   @db.VarChar(255)
  content    String
  sourceType String   @db.VarChar(50)
  url        String?  @db.VarChar(500)
  author     String?  @db.VarChar(255)
  weight     Float    @default(1.0) /// Peso para priorização (1.0 = padrão equilibrado)
  order      Int      @default(0)
  createdAt  DateTime @default(now())
  dossier    Dossier  @relation(fields: [dossierId], references: [id], onDelete: Cascade)

  @@index([dossierId])
  @@index([sourceType])
  @@map("dossier_sources")
}

/// Imagem de referência do dossiê
model DossierImage {
  id          String   @id @default(uuid())
  dossierId   String
  description String
  imageData   Bytes?
  mimeType    String?  @db.VarChar(50)
  url         String?  @db.VarChar(500)
  tags        String?
  order       Int      @default(0)
  createdAt   DateTime @default(now())
  dossier     Dossier  @relation(fields: [dossierId], references: [id], onDelete: Cascade)

  @@index([dossierId])
  @@map("dossier_images")
}

/// Nota de research/insight do usuário
model DossierNote {
  id        String   @id @default(uuid())
  dossierId String
  content   String
  noteType  String?  @db.VarChar(50)
  order     Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  dossier   Dossier  @relation(fields: [dossierId], references: [id], onDelete: Cascade)

  @@index([dossierId])
  @@index([noteType])
  @@map("dossier_notes")
}

/// Pessoa-chave extraída do dossiê (para consistência visual e narrativa)
model DossierPerson {
  id                String   @id @default(uuid())
  dossierId         String
  name              String   @db.VarChar(255)
  role              String?  @db.VarChar(100) /// papel narrativo: investigador, vítima, suspeito, testemunha, etc.
  description       String? /// descrição breve da pessoa e sua relevância
  visualDescription String? /// descrição visual para consistência entre cenas de vídeo
  aliases           String[] /// apelidos, outros nomes conhecidos
  referenceImage    Bytes? /// imagem de referência gerada pelo Photon Flash para consistência visual entre cenas
  relevance         String   @default("secondary") @db.VarChar(20) /// primary | secondary | mentioned
  order             Int      @default(0)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  dossier           Dossier  @relation(fields: [dossierId], references: [id], onDelete: Cascade)

  @@index([dossierId])
  @@map("dossier_persons")
}

// =============================================================================
// PIPELINE ENUMS
// =============================================================================

/// Estágios do pipeline — ordenados por sequência de execução
enum PipelineStage {
  STORY_OUTLINE
  WRITER
  SCRIPT
  RETENTION_QA
  IMAGES
  BGM
  SFX
  AUDIO
  MUSIC_EVENTS
  MOTION
  RENDER
}

/// Status de cada estágio
enum StageStatus {
  NOT_STARTED
  GENERATING
  PENDING_REVIEW
  APPROVED
  REJECTED
  SKIPPED
  FAILED
}

// =============================================================================
// OUTPUT — Config + Identidade (campos de produção, sem estado de workflow)
// =============================================================================

/// Output gerado a partir de um dossiê (vídeo, thread, post, etc.)
/// Contém apenas configuração e identidade. Estado de workflow fica em StageGate.
/// Produtos gerados ficam em tabelas dedicadas (StoryOutlineProduct, RenderProduct, etc.)
model Output {
  id                 String              @id @default(uuid())
  outputType         OutputType
  format             String              @db.VarChar(50)
  title              String?             @db.VarChar(255)

  // ── Parâmetros de produção ──
  duration           Int?
  aspectRatio        String?             @db.VarChar(10)
  platform           String?             @db.VarChar(50)
  targetWPM          Int                 @default(150)
  language           String              @default("pt-BR") @db.VarChar(10)
  narrationLanguage  String              @default("pt-BR") @db.VarChar(10)
  enableMotion       Boolean             @default(false)

  // ── Voz (mutável — usuário pode trocar mid-pipeline) ──
  voiceId            String?             @db.VarChar(100)
  speechConfiguredAt DateTime?           /// Marca que o usuário já configurou voz + velocidade
  ttsProvider        String?             @db.VarChar(50) /// Provider TTS usado (ex: ELEVENLABS, REPLICATE)

  // ── Diretivas editoriais ──
  objective          String? // Objetivo editorial: diretriz narrativa
  mustInclude        String?
  mustExclude        String?

  // ── Referências de estilo (slugs → constantes) ──
  classificationId   String?             @db.VarChar(50)
  scriptStyleId      String?
  visualStyleId      String?
  seedId             String?

  // ── Status denormalizado (para queries rápidas de listagem) ──
  status             OutputStatus        @default(DRAFT)
  errorMessage       String?
  completedAt        DateTime?

  // ── Timestamps ──
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  dossierId          String

  // ── Relations: workflow ──
  stageGates         StageGate[]

  // ── Relations: produtos de cada stage ──
  storyOutlineData   StoryOutlineProduct?
  retentionQAData    RetentionQAProduct?
  monetizationData   MonetizationProduct?
  socialKitData      SocialKitProduct?
  thumbnailProduct   ThumbnailProduct?
  renderProduct      RenderProduct?

  // ── Relations: conteúdo ──
  script             Script?
  scenes             Scene[]
  audioTracks        AudioTrack[]

  // ── Relations: estruturais ──
  dossier            Dossier             @relation(fields: [dossierId], references: [id], onDelete: Cascade)
  seed               Seed?               @relation("OutputSeed", fields: [seedId], references: [id], onDelete: SetNull)
  relationsFrom      OutputRelation[]    @relation("MainOutput")
  relationsTo        OutputRelation[]    @relation("RelatedOutput")
  executions         PipelineExecution[]
  costLogs           CostLog[]

  @@index([dossierId])
  @@index([classificationId])
  @@index([outputType])
  @@index([platform])
  @@index([status])
  @@index([createdAt])
  @@map("outputs")
}

// =============================================================================
// STAGE GATE — Máquina de Estados Explícita (substitui 9 booleans)
// =============================================================================

/// Rastreia o status de aprovação de cada estágio do pipeline.
/// Uma linha por (output, stage). Criada quando o stage é executado pela primeira vez.
model StageGate {
  id         String        @id @default(uuid())
  outputId   String
  stage      PipelineStage
  status     StageStatus   @default(NOT_STARTED)
  feedback   String?       /// Feedback do usuário ao rejeitar/refazer
  executedAt DateTime?     /// Quando o stage foi executado pela última vez
  reviewedAt DateTime?     /// Quando o usuário aprovou/rejeitou
  output     Output        @relation(fields: [outputId], references: [id], onDelete: Cascade)

  @@unique([outputId, stage])
  @@index([outputId])
  @@index([stage, status])
  @@map("stage_gates")
}

// =============================================================================
// PRODUCT TABLES — Cada stage escreve no seu domínio
// =============================================================================

/// Produto do Story Architect — plano narrativo estruturado
model StoryOutlineProduct {
  id          String   @id @default(uuid())
  outputId    String   @unique
  outlineData Json     /// JSON completo do outline (beats, arcos, hooks, openLoops, customScenes, selectedHookLevel)
  provider    String   @db.VarChar(30)
  model       String?  @db.VarChar(100)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  output      Output   @relation(fields: [outputId], references: [id], onDelete: Cascade)

  @@map("story_outline_products")
}

/// Produto do Retention QA — análise de retenção e edit blueprint
model RetentionQAProduct {
  id           String   @id @default(uuid())
  outputId     String   @unique
  overallScore Float    /// Score geral de retenção (0-100)
  summary      String   /// Resumo da análise
  analysisData Json     /// { sceneAnalysis[], editBlueprint, retentionCurve }
  provider     String   @db.VarChar(30)
  model        String?  @db.VarChar(100)
  analyzedAt   DateTime @default(now())
  output       Output   @relation(fields: [outputId], references: [id], onDelete: Cascade)

  @@map("retention_qa_products")
}

/// Produto do Monetizador — contexto de monetização persistido
model MonetizationProduct {
  id          String   @id @default(uuid())
  outputId    String   @unique
  contextData Json     /// { itemType, narrativeRole, angleCategory, avoidPatterns, sceneCount, ... }
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  output      Output   @relation(fields: [outputId], references: [id], onDelete: Cascade)

  @@map("monetization_products")
}

/// Produto do Social Kit — títulos, descrições e hashtags por plataforma
model SocialKitProduct {
  id          String   @id @default(uuid())
  outputId    String   @unique
  kitData     Json     /// { youtube, youtubeShorts, tiktok, instagram, seoTags }
  generatedAt DateTime @default(now())
  output      Output   @relation(fields: [outputId], references: [id], onDelete: Cascade)

  @@map("social_kit_products")
}

/// Produto de Thumbnails — candidatas e thumbnail selecionada
model ThumbnailProduct {
  id                  String    @id @default(uuid())
  outputId            String    @unique
  candidates          Json?     /// Array<{ base64, prompt, hookText }>
  selectedData        Bytes?    /// Thumbnail selecionada (PNG)
  selectedStoragePath String?   @db.VarChar(500) /// Path em object storage
  selectedAt          DateTime?
  createdAt           DateTime  @default(now())
  output              Output    @relation(fields: [outputId], references: [id], onDelete: Cascade)

  @@map("thumbnail_products")
}

/// Produto do Render — vídeo final renderizado
model RenderProduct {
  id                   String   @id @default(uuid())
  outputId             String   @unique

  // ── Vídeo master ──
  videoData            Bytes?              /// Video bytes (para arquivos pequenos)
  videoStoragePath     String?  @db.VarChar(500) /// Path no disco/object storage (para arquivos grandes)
  mimeType             String?  @db.VarChar(50)
  fileSize             Int?

  // ── Versão com legendas ──
  captionedVideoData   Bytes?
  captionedStoragePath String?  @db.VarChar(500)
  captionedFileSize    Int?

  // ── Opções de renderização usadas ──
  renderOptions        Json?    /// { includeLogo, includeCaptions, captionStyleId, volumeOverride }

  renderedAt           DateTime @default(now())
  output               Output   @relation(fields: [outputId], references: [id], onDelete: Cascade)

  @@map("render_products")
}

// =============================================================================
// CONTENT MODELS (Script, Scene, Media)
// =============================================================================

/// Relação entre outputs (ex: teaser → full)
model OutputRelation {
  id              String   @id @default(uuid())
  mainOutputId    String
  relatedOutputId String
  relationType    String   @db.VarChar(50)
  createdAt       DateTime @default(now())
  mainOutput      Output   @relation("MainOutput", fields: [mainOutputId], references: [id], onDelete: Cascade)
  relatedOutput   Output   @relation("RelatedOutput", fields: [relatedOutputId], references: [id], onDelete: Cascade)

  @@unique([mainOutputId, relatedOutputId])
  @@index([relationType])
  @@map("output_relations")
}

/// Roteiro completo do output
model Script {
  id                    String                 @id @default(uuid())
  outputId              String                 @unique
  summary               String
  fullText              String
  wordCount             Int                    @default(0)
  provider              AIProvider
  modelUsed             String?                @db.VarChar(100)
  promptUsed            String?
  writerProse           String? // Prosa narrativa gerada pelo Writer (etapa 1 do pipeline Escritor/Roteirista)
  backgroundMusicPrompt String? // Prompt Stable Audio 2.5 para música única (TikTok/Instagram)
  backgroundMusicVolume Float? // Volume em dB para mixagem (-24 a -6)
  createdAt             DateTime               @default(now())
  updatedAt             DateTime               @updatedAt
  output                Output                 @relation(fields: [outputId], references: [id], onDelete: Cascade)
  backgroundMusicTracks BackgroundMusicTrack[] // Lista de tracks com timestamps (YouTube Cinematic)

  @@map("scripts")
}

/// Cena individual do output
model Scene {
  id                     String       @id @default(uuid())
  outputId               String
  order                  Int
  narration              String
  visualDescription      String
  audioDescription       String?
  audioDescriptionVolume Float? /// Volume do SFX em dB (-24 a -6, null = default -12)
  startTime              Float?
  endTime                Float?
  estimatedDuration      Float        @default(5)
  sceneEnvironment       String?      @db.VarChar(100) /// Identificador de ambiente para continuidade visual
  motionDescription      String? /// Instruções de movimento para i2v
  characterRef           String? /// ID do DossierPerson para referência visual

  // --- Viral-first fields (Retention QA + Edit Blueprint) ---
  onScreenText           String?      @db.VarChar(120) /// Texto overlay queimado no render
  patternInterruptType   String?      @db.VarChar(50) /// zoom|whip_pan|hard_cut|smash_cut|glitch|freeze|rack_focus|speed_ramp
  brollPriority          Int          @default(1) /// 0=simples, 1=padrão, 2=hero shot
  riskFlags              String[] /// ["slow","expository","confusing","low_energy","redundant"]

  imageStatus            String       @default("pending") @db.VarChar(20) /// pending | generated | restricted | error
  imageRestrictionReason String?
  createdAt              DateTime     @default(now())
  updatedAt              DateTime     @updatedAt
  images                 SceneImage[]
  videos                 SceneVideo[]
  audioTracks            AudioTrack[]
  output                 Output       @relation(fields: [outputId], references: [id], onDelete: Cascade)

  @@index([outputId])
  @@index([outputId, order])
  @@map("scenes")
}

/// Track de música de fundo por segmento de cenas (para vídeos longos YouTube)
model BackgroundMusicTrack {
  id         String   @id @default(uuid())
  scriptId   String
  prompt     String // Prompt Stable Audio 2.5 (gênero, instrumentos, BPM, mood)
  volume     Float    @default(-18) // Volume em dB para mixagem (-24 a -6)
  startScene Int // Cena onde esta track começa (0 = primeira cena)
  endScene   Int? // Última cena desta track (null = até a última cena)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  script     Script   @relation(fields: [scriptId], references: [id], onDelete: Cascade)

  @@index([scriptId])
  @@map("background_music_tracks")
}

/// Imagem gerada para uma cena
model SceneImage {
  id           String     @id @default(uuid())
  sceneId      String
  role         String     @default("start") @db.VarChar(10) /// "start" = imagem de início da cena
  provider     AIProvider
  promptUsed   String
  fileData     Bytes?
  storagePath  String?    @db.VarChar(500) /// Path em object storage (futuro)
  mimeType     String?    @db.VarChar(50)
  originalSize Int?
  width        Int?
  height       Int?
  isSelected   Boolean    @default(false)
  createdAt    DateTime   @default(now())
  scene        Scene      @relation(fields: [sceneId], references: [id], onDelete: Cascade)

  @@index([sceneId])
  @@map("scene_images")
}

/// Vídeo/Motion gerado para uma cena
model SceneVideo {
  id            String     @id @default(uuid())
  sceneId       String
  provider      AIProvider
  promptUsed    String?
  fileData      Bytes?
  storagePath   String?    @db.VarChar(500) /// Path em object storage (futuro)
  mimeType      String?    @db.VarChar(50)
  originalSize  Int?
  duration      Float?
  sourceImageId String?
  isSelected    Boolean    @default(false)
  createdAt     DateTime   @default(now())
  scene         Scene      @relation(fields: [sceneId], references: [id], onDelete: Cascade)

  @@index([sceneId])
  @@map("scene_videos")
}

/// Trilha de áudio gerada
model AudioTrack {
  id           String     @id @default(uuid())
  outputId     String
  sceneId      String?
  type         String     @db.VarChar(50)
  provider     AIProvider
  voiceId      String?    @db.VarChar(100)
  fileData     Bytes?
  storagePath  String?    @db.VarChar(500) /// Path em object storage (futuro)
  mimeType     String?    @db.VarChar(50)
  originalSize Int?
  duration     Float?
  offsetMs     Int?       /// Offset em ms do início do vídeo (para stingers/music events posicionados)
  alignment    Json? /// Word-level timestamps do ElevenLabs: [{word, startTime, endTime}]
  createdAt    DateTime   @default(now())
  output       Output     @relation(fields: [outputId], references: [id], onDelete: Cascade)
  scene        Scene?     @relation(fields: [sceneId], references: [id], onDelete: SetNull)

  @@index([outputId])
  @@index([sceneId])
  @@map("audio_tracks")
}

// =============================================================================
// INFRASTRUCTURE (Config, Seeds, Costs, Logs)
// =============================================================================

/// Configuração de provedores de IA
model ProviderConfig {
  id                String     @id @default(uuid())
  provider          AIProvider @unique
  apiKey            String     @db.VarChar(500)
  isActive          Boolean    @default(true)
  settings          Json?
  requestsPerMinute Int?
  createdAt         DateTime   @default(now())
  updatedAt         DateTime   @updatedAt

  @@map("provider_configs")
}

/// Logs de execução do pipeline
model PipelineExecution {
  id         String   @id @default(uuid())
  outputId   String
  step       String   @db.VarChar(50)
  status     String   @db.VarChar(20)
  message    String?
  metadata   Json?
  durationMs Int?
  createdAt  DateTime @default(now())
  output     Output   @relation(fields: [outputId], references: [id], onDelete: Cascade)

  @@index([outputId])
  @@index([createdAt])
  @@map("pipeline_executions")
}

/// Seeds para geração de imagens/vídeos (receitas visuais)
model Seed {
  id                  String       @id @default(uuid())
  value               Int          @unique
  usageCount          Int          @default(0)
  createdAt           DateTime     @default(now())
  updatedAt           DateTime     @updatedAt
  outputs             Output[]     @relation("OutputSeed")
  samples             SeedSample[] @relation("SeedSamples")
  preferredByDossiers Dossier[]    @relation("DossierPreferredSeed")
  preferredByChannels Channel[]    @relation("ChannelDefaultSeed")

  @@map("seeds")
}

/// Amostra visual gerada com uma seed
model SeedSample {
  id          String   @id @default(uuid())
  seedId      String
  dossierId   String?
  source      String   @db.VarChar(50) /// "style-preview" | "scene-image" | "thumbnail" | "test"
  prompt      String
  base64      String
  mimeType    String   @default("image/png") @db.VarChar(30)
  provider    String   @db.VarChar(30)
  model       String?  @db.VarChar(100)
  aspectRatio String?  @db.VarChar(10)
  metadata    Json?
  createdAt   DateTime @default(now())
  seed        Seed     @relation("SeedSamples", fields: [seedId], references: [id], onDelete: Cascade)
  dossier     Dossier? @relation("DossierSeedSamples", fields: [dossierId], references: [id], onDelete: SetNull)

  @@index([seedId])
  @@index([dossierId])
  @@index([source])
  @@index([createdAt])
  @@map("seed_samples")
}

/// Log de custos de API - append-only ledger
model CostLog {
  id        String   @id @default(uuid())
  outputId  String?
  dossierId String?
  resource  String   @db.VarChar(50)
  action    String   @db.VarChar(20)
  provider  String   @db.VarChar(30)
  model     String?  @db.VarChar(100)
  cost      Float
  metadata  Json?
  detail    String?  @db.VarChar(255)
  createdAt DateTime @default(now())
  output    Output?  @relation(fields: [outputId], references: [id], onDelete: Restrict)
  dossier   Dossier? @relation(fields: [dossierId], references: [id], onDelete: Restrict)

  @@index([outputId])
  @@index([dossierId])
  @@index([resource])
  @@index([createdAt])
  @@map("cost_logs")
}

/// Plano de monetização gerado pela IA (Document-First Strategy)
model MonetizationPlan {
  id                String   @id @default(uuid())
  dossierId         String
  planData          Json
  teaserDuration    Int
  fullVideoDuration Int
  teaserCount       Int      @default(0)
  provider          String   @db.VarChar(30)
  model             String?  @db.VarChar(100)
  inputTokens       Int      @default(0)
  outputTokens      Int      @default(0)
  cost              Float    @default(0)
  isActive          Boolean  @default(true)
  createdAt         DateTime @default(now())
  dossier           Dossier  @relation(fields: [dossierId], references: [id], onDelete: Cascade)

  @@index([dossierId])
  @@index([isActive])
  @@index([createdAt])
  @@map("monetization_plans")
}

/// Provider de IA configurável (LLM ou Mídia)
model LlmProvider {
  id          String   @id @db.VarChar(30)
  name        String   @db.VarChar(50)
  description String?  @db.Text
  apiKey      String?  @db.Text
  baseUrl     String?  @db.VarChar(200)
  iconKey     String   @default("brain") @db.VarChar(30)
  category    String   @default("llm") @db.VarChar(20)
  isActive    Boolean  @default(true)
  extraConfig Json?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  models      LlmModel[]

  @@map("llm_providers")
}

/// Modelo de LLM disponível dentro de um provider
model LlmModel {
  id                       String   @id @default(uuid())
  modelId                  String   @db.VarChar(100)
  name                     String   @db.VarChar(100)
  providerId               String   @db.VarChar(30)
  contextWindow            Int      @default(128000)
  costTier                 Int      @default(2)
  supportsStructuredOutput Boolean  @default(true)
  supportsVision           Boolean  @default(false)
  isActive                 Boolean  @default(true)
  inputSchema              Json?
  createdAt                DateTime @default(now())
  updatedAt                DateTime @updatedAt
  provider                 LlmProvider @relation(fields: [providerId], references: [id], onDelete: Cascade)

  @@unique([providerId, modelId])
  @@map("llm_models")
}

/// Assignment de provider/modelo de IA por task
model LlmAssignment {
  id          String   @id @default(uuid())
  taskId      String   @unique @db.VarChar(50)
  provider    String   @db.VarChar(30)
  model       String   @db.VarChar(100)
  temperature Float    @default(0.7)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("llm_assignments")
}

/// Assignment de provider/modelo de MÍDIA por task
model MediaAssignment {
  id          String   @id @default(uuid())
  taskId      String   @unique @db.VarChar(50)
  provider    String   @db.VarChar(30)
  model       String   @db.VarChar(150)
  extraConfig Json?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("media_assignments")
}

// =============================================================================
// ENUMS
// =============================================================================

/// Tipo de provedor de IA usado
enum AIProvider {
  OPENAI
  ANTHROPIC
  GEMINI
  GROQ
  ELEVENLABS
  MIDJOURNEY
  STABLE_DIFFUSION
  RUNWAY
  REPLICATE
}

/// Tipo de output gerado
enum OutputType {
  VIDEO_TEASER
  VIDEO_FULL
  TWITTER_THREAD
  LINKEDIN_POST
  INSTAGRAM_POST
  PODCAST_EPISODE
  BLOG_ARTICLE
}

/// Status de geração do output
enum OutputStatus {
  DRAFT
  IN_PROGRESS
  RENDERED
  COMPLETED
  FAILED
  CANCELLED
}

// =============================================================================
// CONTENT MODELS (News, Hooks)
// =============================================================================

/// Notícia capturada pelo Radar de Inteligência
model NewsItem {
  id          String    @id @default(uuid())
  title       String
  link        String    @unique
  summary     String?
  source      String    @db.VarChar(100)
  category    String    @db.VarChar(50)
  author      String?   @db.VarChar(200)
  publishedAt DateTime?
  fetchedAt   DateTime  @default(now())
  dismissed   Boolean   @default(false)

  @@index([category])
  @@index([fetchedAt])
  @@map("news_items")
}

/// Hook narrativo curado para inspirar aberturas poderosas
model NarrativeHook {
  id                   String   @id @default(uuid())
  type                 String   @db.VarChar(50)
  sourceType           String   @db.VarChar(50)
  sourceTitle          String   @db.VarChar(255)
  genres               String[]
  hookText             String   @db.Text
  duration             String   @db.VarChar(20)
  emotionalTemperature String   @db.VarChar(50)
  tags                 String[]
  structuralPattern    String?
  structuralElements   String[]
  pacing               String?  @db.VarChar(20)
  whyItWorks           String?  @db.Text
  usageCount           Int      @default(0)
  isActive             Boolean  @default(true)
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  @@index([type])
  @@index([sourceType])
  @@index([emotionalTemperature])
  @@index([isActive])
  @@map("narrative_hooks")
}
