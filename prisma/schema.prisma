generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

/// Canal de conteúdo (ex: The Gap Files, Canal X) — entidade raiz multi-canal
model Channel {
  id                   String    @id @default(uuid())
  name                 String    @db.VarChar(100)
  handle               String    @unique @db.VarChar(50)
  description          String?
  platform             String?   @db.VarChar(50)
  logoBase64           String? /// Logo do canal em base64
  logoMimeType         String?   @db.VarChar(50)
  defaultVisualStyleId String?   @db.VarChar(50) /// slug → constant (visual-styles.ts)
  defaultScriptStyleId String?   @db.VarChar(50) /// slug → constant (script-styles.ts)
  defaultSeedId        String?
  isActive             Boolean   @default(true)
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt
  dossiers             Dossier[]
  defaultSeed          Seed?     @relation("ChannelDefaultSeed", fields: [defaultSeedId], references: [id], onDelete: SetNull)

  @@map("channels")
}

/// Dossiê - centro do sistema, contém todos materiais de research e pode gerar múltiplos outputs
/// Fontes são gerenciadas exclusivamente via DossierSource (arquitetura flat/democratizada)
model Dossier {
  id                     String             @id @default(uuid())
  title                  String             @db.VarChar(255)
  theme                  String
  researchData           Json?
  tags                   String[]
  isProcessed            Boolean            @default(false)
  visualIdentityContext  String?            @db.VarChar(500) // Contexto visual do dossier
  researchPrompt         String?            @db.Text // Prompt gerado pelo Investigador para Gemini Deep Research
  preferredVisualStyleId String?
  preferredSeedId        String?
  channelId              String? /// FK → Channel (nullable para migração gradual)
  createdAt              DateTime           @default(now())
  updatedAt              DateTime           @updatedAt
  images                 DossierImage[]
  notes                  DossierNote[]
  persons                DossierPerson[]
  sources                DossierSource[]
  outputs                Output[]
  costLogs               CostLog[]
  monetizationPlans      MonetizationPlan[]
  seedSamples            SeedSample[]       @relation("DossierSeedSamples")
  preferredSeed          Seed?              @relation("DossierPreferredSeed", fields: [preferredSeedId], references: [id], onDelete: SetNull)
  channel                Channel?           @relation(fields: [channelId], references: [id], onDelete: SetNull)

  @@index([createdAt])
  @@index([isProcessed])
  @@index([channelId])
  @@map("dossiers")
}

/// Fonte do dossiê (todas as fontes são tratadas igualmente — arquitetura flat/democratizada)
/// sourceType indica a natureza: 'document' (documento primário migrado), 'url', 'text', 'pdf'
/// weight permite priorização opcional (padrão 1.0 = todas iguais)
model DossierSource {
  id         String   @id @default(uuid())
  dossierId  String
  title      String   @db.VarChar(255)
  content    String
  sourceType String   @db.VarChar(50)
  url        String?  @db.VarChar(500)
  author     String?  @db.VarChar(255)
  weight     Float    @default(1.0) /// Peso para priorização (1.0 = padrão equilibrado)
  order      Int      @default(0)
  createdAt  DateTime @default(now())
  dossier    Dossier  @relation(fields: [dossierId], references: [id], onDelete: Cascade)

  @@index([dossierId])
  @@index([sourceType])
  @@map("dossier_sources")
}

/// Imagem de referência do dossiê
model DossierImage {
  id          String   @id @default(uuid())
  dossierId   String
  description String
  imageData   Bytes?
  mimeType    String?  @db.VarChar(50)
  url         String?  @db.VarChar(500)
  tags        String?
  order       Int      @default(0)
  createdAt   DateTime @default(now())
  dossier     Dossier  @relation(fields: [dossierId], references: [id], onDelete: Cascade)

  @@index([dossierId])
  @@map("dossier_images")
}

/// Nota de research/insight do usuário
model DossierNote {
  id        String   @id @default(uuid())
  dossierId String
  content   String
  noteType  String?  @db.VarChar(50)
  order     Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  dossier   Dossier  @relation(fields: [dossierId], references: [id], onDelete: Cascade)

  @@index([dossierId])
  @@index([noteType])
  @@map("dossier_notes")
}

/// Pessoa-chave extraída do dossiê (para consistência visual e narrativa)
model DossierPerson {
  id                String   @id @default(uuid())
  dossierId         String
  name              String   @db.VarChar(255)
  role              String?  @db.VarChar(100) /// papel narrativo: investigador, vítima, suspeito, testemunha, etc.
  description       String? /// descrição breve da pessoa e sua relevância
  visualDescription String? /// descrição visual para consistência entre cenas de vídeo
  aliases           String[] /// apelidos, outros nomes conhecidos
  relevance         String   @default("secondary") @db.VarChar(20) /// primary | secondary | mentioned
  order             Int      @default(0)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  dossier           Dossier  @relation(fields: [dossierId], references: [id], onDelete: Cascade)

  @@index([dossierId])
  @@map("dossier_persons")
}

/// Output gerado a partir de um dossiê (vídeo, thread, post, etc.)
model Output {
  id                   String              @id @default(uuid())
  outputType           OutputType
  format               String              @db.VarChar(50)
  title                String?             @db.VarChar(255)
  duration             Int?
  aspectRatio          String?             @db.VarChar(10)
  platform             String?             @db.VarChar(50)
  targetWPM            Int                 @default(150)
  language             String              @default("pt-BR") @db.VarChar(10)
  narrationLanguage    String              @default("pt-BR") @db.VarChar(10)
  voiceId              String?             @db.VarChar(100)
  ttsProvider          String?             @db.VarChar(50) /// Provider TTS usado (ex: ELEVENLABS, REPLICATE)
  enableMotion         Boolean             @default(false)
  objective            String? // Objetivo editorial: diretriz narrativa que governa a geração do roteiro
  mustInclude          String?
  mustExclude          String?
  classificationId     String?             @db.VarChar(50) // Tema/tonalidade (intelligence-classifications). Pai: define script e visual recomendados.
  scriptStyleId        String?
  visualStyleId        String?
  seedId               String?
  status               OutputStatus        @default(PENDING)
  scriptApproved       Boolean             @default(false)
  imagesApproved       Boolean             @default(false)
  bgmApproved          Boolean             @default(false)
  audioApproved        Boolean             @default(false)
  videosApproved       Boolean             @default(false)
  renderApproved       Boolean             @default(false)
  outputData           Bytes?
  outputMimeType       String?             @db.VarChar(50)
  outputSize           Int?
  captionedVideoData   Bytes?
  captionedVideoSize   Int?
  thumbnailPath        String?             @db.VarChar(500)
  thumbnailData        Bytes?
  thumbnailCandidates  Json?
  socialKit            Json? // Kit de publicação: títulos, descrições e hashtags por plataforma
  outputPath           String?             @db.VarChar(500)
  errorMessage         String?
  pipelineLog          Json?
  /// Opções para esta renderização: legendas/logo aplicados no pipeline antes de salvar (uma gravação)
  renderOptions        Json? // { includeLogo?: boolean, includeCaptions?: boolean, captionStyleId?: string | null }
  storyOutline         Json? // Story Architect: plano narrativo estruturado (etapa isolada)
  storyOutlineApproved Boolean             @default(false) // Validação obrigatória antes de gerar roteiro
  monetizationContext  Json? // Contexto de monetização persistido: { itemType, narrativeRole, angleCategory, avoidPatterns, ... }
  createdAt            DateTime            @default(now())
  updatedAt            DateTime            @updatedAt
  completedAt          DateTime?
  dossierId            String
  audioTracks          AudioTrack[]
  relationsFrom        OutputRelation[]    @relation("MainOutput")
  relationsTo          OutputRelation[]    @relation("RelatedOutput")
  dossier              Dossier             @relation(fields: [dossierId], references: [id], onDelete: Cascade)
  seed                 Seed?               @relation("OutputSeed", fields: [seedId], references: [id], onDelete: SetNull)
  executions           PipelineExecution[]
  scenes               Scene[]
  script               Script?
  costLogs             CostLog[]

  @@index([dossierId])
  @@index([classificationId])
  @@index([outputType])
  @@index([platform])
  @@index([status])
  @@index([createdAt])
  @@map("outputs")
}

/// Relação entre outputs (ex: teaser → full)
model OutputRelation {
  id              String   @id @default(uuid())
  mainOutputId    String
  relatedOutputId String
  relationType    String   @db.VarChar(50)
  createdAt       DateTime @default(now())
  mainOutput      Output   @relation("MainOutput", fields: [mainOutputId], references: [id], onDelete: Cascade)
  relatedOutput   Output   @relation("RelatedOutput", fields: [relatedOutputId], references: [id], onDelete: Cascade)

  @@unique([mainOutputId, relatedOutputId])
  @@index([relationType])
  @@map("output_relations")
}

/// Roteiro completo do output
model Script {
  id                    String                 @id @default(uuid())
  outputId              String                 @unique
  summary               String
  fullText              String
  wordCount             Int                    @default(0)
  provider              AIProvider
  modelUsed             String?                @db.VarChar(100)
  promptUsed            String?
  backgroundMusicPrompt String? // Prompt Stable Audio 2.5 para música única (TikTok/Instagram)
  backgroundMusicVolume Float? // Volume em dB para mixagem (-24 a -6)
  createdAt             DateTime               @default(now())
  updatedAt             DateTime               @updatedAt
  output                Output                 @relation(fields: [outputId], references: [id], onDelete: Cascade)
  backgroundMusicTracks BackgroundMusicTrack[] // Lista de tracks com timestamps (YouTube Cinematic)

  @@map("scripts")
}

/// Cena individual do output
model Scene {
  id                     String       @id @default(uuid())
  outputId               String
  order                  Int
  narration              String
  visualDescription      String
  audioDescription       String?
  startTime              Float?
  endTime                Float?
  estimatedDuration      Float        @default(5)
  sceneEnvironment       String?      @db.VarChar(100) /// Identificador de ambiente (ex: "bishop_study", "canal") para agrupamento de continuidade visual
  motionDescription      String? /// Instruções de movimento para i2v (câmera, sujeito, atmosfera dinâmica). Usado no pipeline de motion em vez de visualDescription.
  imageStatus            String       @default("pending") @db.VarChar(20) /// pending | generated | restricted | error
  imageRestrictionReason String? /// Razão da restrição pelo filtro de conteúdo
  createdAt              DateTime     @default(now())
  updatedAt              DateTime     @updatedAt
  images                 SceneImage[]
  videos                 SceneVideo[]
  audioTracks            AudioTrack[]
  output                 Output       @relation(fields: [outputId], references: [id], onDelete: Cascade)

  @@index([outputId])
  @@index([outputId, order])
  @@map("scenes")
}

/// Track de música de fundo por segmento de cenas (para vídeos longos YouTube)
model BackgroundMusicTrack {
  id         String   @id @default(uuid())
  scriptId   String
  prompt     String // Prompt Stable Audio 2.5 (gênero, instrumentos, BPM, mood)
  volume     Float    @default(-18) // Volume em dB para mixagem (-24 a -6)
  startScene Int // Cena onde esta track começa (0 = primeira cena)
  endScene   Int? // Última cena desta track (null = até a última cena)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  script     Script   @relation(fields: [scriptId], references: [id], onDelete: Cascade)

  @@index([scriptId])
  @@map("background_music_tracks")
}

/// Imagem gerada para uma cena
model SceneImage {
  id           String     @id @default(uuid())
  sceneId      String
  provider     AIProvider
  promptUsed   String
  fileData     Bytes?
  mimeType     String?    @db.VarChar(50)
  originalSize Int?
  width        Int?
  height       Int?
  isSelected   Boolean    @default(false)
  variantIndex Int        @default(0)
  createdAt    DateTime   @default(now())
  scene        Scene      @relation(fields: [sceneId], references: [id], onDelete: Cascade)

  @@index([sceneId])
  @@map("scene_images")
}

/// Vídeo/Motion gerado para uma cena
model SceneVideo {
  id            String     @id @default(uuid())
  sceneId       String
  provider      AIProvider
  promptUsed    String?
  fileData      Bytes?
  mimeType      String?    @db.VarChar(50)
  originalSize  Int?
  duration      Float?
  sourceImageId String?
  isSelected    Boolean    @default(false)
  variantIndex  Int        @default(0)
  createdAt     DateTime   @default(now())
  scene         Scene      @relation(fields: [sceneId], references: [id], onDelete: Cascade)

  @@index([sceneId])
  @@map("scene_videos")
}

/// Trilha de áudio gerada
model AudioTrack {
  id           String     @id @default(uuid())
  outputId     String
  sceneId      String?
  type         String     @db.VarChar(50)
  provider     AIProvider
  voiceId      String?    @db.VarChar(100)
  fileData     Bytes?
  mimeType     String?    @db.VarChar(50)
  originalSize Int?
  duration     Float?
  alignment    Json? /// Word-level timestamps do ElevenLabs: [{word, startTime, endTime}]
  createdAt    DateTime   @default(now())
  output       Output     @relation(fields: [outputId], references: [id], onDelete: Cascade)
  scene        Scene?     @relation(fields: [sceneId], references: [id], onDelete: SetNull)

  @@index([outputId])
  @@index([sceneId])
  @@map("audio_tracks")
}

/// Configuração de provedores de IA
model ProviderConfig {
  id                String     @id @default(uuid())
  provider          AIProvider @unique
  apiKey            String     @db.VarChar(500)
  isActive          Boolean    @default(true)
  settings          Json?
  requestsPerMinute Int?
  createdAt         DateTime   @default(now())
  updatedAt         DateTime   @updatedAt

  @@map("provider_configs")
}

/// Logs de execução do pipeline
model PipelineExecution {
  id         String   @id @default(uuid())
  outputId   String
  step       String   @db.VarChar(50)
  status     String   @db.VarChar(20)
  message    String?
  metadata   Json?
  durationMs Int?
  createdAt  DateTime @default(now())
  output     Output   @relation(fields: [outputId], references: [id], onDelete: Cascade)

  @@index([outputId])
  @@index([createdAt])
  @@map("pipeline_executions")
}

/// NOTA: VisualStyle e ScriptStyle foram migrados para constantes em
/// server/constants/visual-styles.ts e server/constants/script-styles.ts
/// Os campos scriptStyleId e visualStyleId agora armazenam slugs de string.

/// Seeds para geração de imagens/vídeos (receitas visuais)
model Seed {
  id                  String       @id @default(uuid())
  value               Int          @unique
  usageCount          Int          @default(0)
  createdAt           DateTime     @default(now())
  updatedAt           DateTime     @updatedAt
  outputs             Output[]     @relation("OutputSeed")
  samples             SeedSample[] @relation("SeedSamples")
  preferredByDossiers Dossier[]    @relation("DossierPreferredSeed")
  preferredByChannels Channel[]    @relation("ChannelDefaultSeed")

  @@map("seeds")
}

/// Amostra visual gerada com uma seed — registro universal de qualquer imagem
/// produzida pelo sistema (style preview, pipeline de cenas, thumbnail, etc.)
/// Permite consultar todas as imagens de uma seed na gestão de seeds.
model SeedSample {
  id          String   @id @default(uuid())
  seedId      String
  dossierId   String? /// Contexto opcional: dossiê de onde veio a geração
  source      String   @db.VarChar(50) /// "style-preview" | "scene-image" | "thumbnail" | "test"
  prompt      String /// Prompt usado na geração
  base64      String /// Imagem em base64 (sem prefixo data:...)
  mimeType    String   @default("image/png") @db.VarChar(30)
  provider    String   @db.VarChar(30) /// "REPLICATE"
  model       String?  @db.VarChar(100) /// ex: "luma/photon-flash"
  aspectRatio String?  @db.VarChar(10) /// "16:9", "9:16", "1:1"
  metadata    Json? /// Dados extras: visualStyleId, itemKey, predictTime, etc.
  createdAt   DateTime @default(now())
  seed        Seed     @relation("SeedSamples", fields: [seedId], references: [id], onDelete: Cascade)
  dossier     Dossier? @relation("DossierSeedSamples", fields: [dossierId], references: [id], onDelete: SetNull)

  @@index([seedId])
  @@index([dossierId])
  @@index([source])
  @@index([createdAt])
  @@map("seed_samples")
}

/// Log de custos de API - append-only ledger desacoplado dos artefatos
/// Cada registro pertence a um output (pipeline de vídeo) OU a um dossier (ex: análise neural).
model CostLog {
  id        String   @id @default(uuid())
  outputId  String? /// null quando o custo é de recurso do dossier (ex: insights)
  dossierId String? /// preenchido para custos no nível do dossier (análise neural)
  resource  String   @db.VarChar(50) /// "outline" | "script" | "image" | "narration" | "bgm" | "motion" | "insights"
  action    String   @db.VarChar(20) /// "create" | "recreate"
  provider  String   @db.VarChar(30) /// "REPLICATE" | "ELEVENLABS" | "OPENAI" | "ANTHROPIC"
  model     String?  @db.VarChar(100) /// ex: "black-forest-labs/flux-schnell"
  cost      Float /// Custo em USD
  metadata  Json? /// Dados de cálculo: predict_time, characters, tokens, etc
  detail    String?  @db.VarChar(255) /// Descrição legível
  createdAt DateTime @default(now())
  output    Output?  @relation(fields: [outputId], references: [id], onDelete: Restrict)
  dossier   Dossier? @relation(fields: [dossierId], references: [id], onDelete: Restrict)

  @@index([outputId])
  @@index([dossierId])
  @@index([resource])
  @@index([createdAt])
  @@map("cost_logs")
}

/// Plano de monetização gerado pela IA (Document-First Strategy)
/// Armazena o JSON completo do plano para exibição posterior sem regenerar.
model MonetizationPlan {
  id                String   @id @default(uuid())
  dossierId         String
  planData          Json /// JSON completo do plano: fullVideo, teasers[], publicationSchedule[], etc.
  teaserDuration    Int /// Duração configurada dos teasers (35, 55 ou 115 segundos)
  fullVideoDuration Int /// Duração configurada do full video (300, 600 ou 900 segundos)
  teaserCount       Int      @default(0) /// Quantidade de teasers no plano
  provider          String   @db.VarChar(30) /// "OPENAI" | "ANTHROPIC"
  model             String?  @db.VarChar(100) /// ex: "claude-sonnet-4-20250514"
  inputTokens       Int      @default(0)
  outputTokens      Int      @default(0)
  cost              Float    @default(0) /// Custo em USD da geração
  isActive          Boolean  @default(true) /// false = substituído por um plano mais novo
  createdAt         DateTime @default(now())
  dossier           Dossier  @relation(fields: [dossierId], references: [id], onDelete: Cascade)

  @@index([dossierId])
  @@index([isActive])
  @@index([createdAt])
  @@map("monetization_plans")
}

/// Provider de IA configurável (LLM ou Mídia)
/// Gerenciado pela UI em /settings/providers — API keys ficam aqui, não no .env
model LlmProvider {
  id          String   @id @db.VarChar(30) /// Ex: "openai", "anthropic", "replicate", "elevenlabs"
  name        String   @db.VarChar(50) /// Ex: "OpenAI", "Replicate"
  description String?  @db.Text
  apiKey      String?  @db.Text /// API Key (criptografar em prod)
  baseUrl     String?  @db.VarChar(200) /// Base URL customizada
  iconKey     String   @default("brain") @db.VarChar(30)
  category    String   @default("llm") @db.VarChar(20) /// "llm" | "media" — separa LLMs de providers de mídia
  isActive    Boolean  @default(true)
  extraConfig Json? /// Config extra (ex: endpointId para RunPod, voiceId para ElevenLabs)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  models LlmModel[]

  @@map("llm_providers")
}

/// Modelo de LLM disponível dentro de um provider
model LlmModel {
  id                       String   @id @default(uuid())
  modelId                  String   @db.VarChar(100) /// ID na API (ex: "gpt-4o", "claude-sonnet-4-20250514")
  name                     String   @db.VarChar(100) /// Nome legível (ex: "GPT-4o")
  providerId               String   @db.VarChar(30)
  contextWindow            Int      @default(128000)
  costTier                 Int      @default(2) /// 1-5 (1=barato, 5=caro)
  supportsStructuredOutput Boolean  @default(true)
  supportsVision           Boolean  @default(false)
  isActive                 Boolean  @default(true)
  inputSchema              Json? /// Schema de input do modelo — define como montar o payload para a API
  createdAt                DateTime @default(now())
  updatedAt                DateTime @updatedAt

  provider LlmProvider @relation(fields: [providerId], references: [id], onDelete: Cascade)

  @@unique([providerId, modelId])
  @@map("llm_models")
}

/// Assignment de provider/modelo de IA por task — persistido no banco.
/// Cada task (script, analysis, story-architect, etc.) tem UMA linha nesta tabela.
/// Quando não existe registro, o sistema usa os defaults do LLM Registry.
model LlmAssignment {
  id          String   @id @default(uuid())
  taskId      String   @unique @db.VarChar(50) /// Ex: "script", "analysis", "monetization"
  provider    String   @db.VarChar(30) /// Ex: "openai", "anthropic", "groq"
  model       String   @db.VarChar(100) /// Ex: "gpt-4o", "claude-sonnet-4-20250514"
  temperature Float    @default(0.7) /// 0.0 a 2.0
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("llm_assignments")
}

/// Assignment de provider/modelo de MÍDIA por task (imagem, TTS, motion, música).
/// Mesma lógica do LlmAssignment mas para providers de mídia (Replicate, ElevenLabs, RunPod).
model MediaAssignment {
  id          String   @id @default(uuid())
  taskId      String   @unique @db.VarChar(50) /// Ex: "image-generation", "tts-narration", "motion-video", "background-music", "thumbnail"
  provider    String   @db.VarChar(30) /// Ex: "replicate", "elevenlabs", "runpod"
  model       String   @db.VarChar(150) /// Ex: "luma/photon-flash", "eleven_multilingual_v2"
  extraConfig Json? /// Config extra por task (ex: voiceId, endpointId, seed, steps)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("media_assignments")
}

/// Tipo de provedor de IA usado
enum AIProvider {
  OPENAI
  ANTHROPIC
  GEMINI
  GROQ
  ELEVENLABS
  MIDJOURNEY
  STABLE_DIFFUSION
  RUNWAY
  REPLICATE
}

/// Tipo de output gerado a partir de um documento
enum OutputType {
  VIDEO_TEASER
  VIDEO_FULL
  TWITTER_THREAD
  LINKEDIN_POST
  INSTAGRAM_POST
  PODCAST_EPISODE
  BLOG_ARTICLE
}

/// Status de geração do output
enum OutputStatus {
  PENDING
  GENERATING
  RENDERED
  COMPLETED
  FAILED
  CANCELLED
}

/// Notícia capturada pelo Radar de Inteligência (persistida para não perder quando RSS expirar)
model NewsItem {
  id          String    @id @default(uuid())
  title       String
  link        String    @unique // URL da notícia — deduplicação natural
  summary     String?
  source      String    @db.VarChar(100) // Nome do feed (ex: "CrimeReads")
  category    String    @db.VarChar(50) // paranormal, science, true-crime, serial-killer, geopolitics, etc.
  author      String?   @db.VarChar(200)
  publishedAt DateTime? // Data de publicação original (do RSS)
  fetchedAt   DateTime  @default(now()) // Quando foi capturada pelo sistema
  dismissed   Boolean   @default(false) // Para filtrar sinais já descartados

  @@index([category])
  @@index([fetchedAt])
  @@map("news_items")
}
