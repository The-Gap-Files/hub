generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

/// Dossiê - centro do sistema, contém todos materiais de research e pode gerar múltiplos outputs
model Dossier {
  id                     String             @id @default(uuid())
  title                  String             @db.VarChar(255)
  sourceText             String
  theme                  String
  researchData           Json?
  tags                   String[]
  isProcessed            Boolean            @default(false)
  visualIdentityContext  String?            @db.VarChar(500) // Contexto visual do dossier
  preferredVisualStyleId String?
  preferredSeedId        String?
  createdAt              DateTime           @default(now())
  updatedAt              DateTime           @updatedAt
  images                 DossierImage[]
  notes                  DossierNote[]
  sources                DossierSource[]
  outputs                Output[]
  costLogs               CostLog[]
  monetizationPlans      MonetizationPlan[]
  preferredSeed          Seed?              @relation("DossierPreferredSeed", fields: [preferredSeedId], references: [id], onDelete: SetNull)

  @@index([createdAt])
  @@index([isProcessed])
  @@map("dossiers")
}

/// Fonte secundária do dossiê (artigo, paper, citação)
model DossierSource {
  id         String   @id @default(uuid())
  dossierId  String
  title      String   @db.VarChar(255)
  content    String
  sourceType String   @db.VarChar(50)
  url        String?  @db.VarChar(500)
  author     String?  @db.VarChar(255)
  order      Int      @default(0)
  createdAt  DateTime @default(now())
  dossier    Dossier  @relation(fields: [dossierId], references: [id], onDelete: Cascade)

  @@index([dossierId])
  @@index([sourceType])
  @@map("dossier_sources")
}

/// Imagem de referência do dossiê
model DossierImage {
  id          String   @id @default(uuid())
  dossierId   String
  description String
  imageData   Bytes?
  mimeType    String?  @db.VarChar(50)
  url         String?  @db.VarChar(500)
  tags        String?
  order       Int      @default(0)
  createdAt   DateTime @default(now())
  dossier     Dossier  @relation(fields: [dossierId], references: [id], onDelete: Cascade)

  @@index([dossierId])
  @@map("dossier_images")
}

/// Nota de research/insight do usuário
model DossierNote {
  id        String   @id @default(uuid())
  dossierId String
  content   String
  noteType  String?  @db.VarChar(50)
  order     Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  dossier   Dossier  @relation(fields: [dossierId], references: [id], onDelete: Cascade)

  @@index([dossierId])
  @@index([noteType])
  @@map("dossier_notes")
}

/// Output gerado a partir de um dossiê (vídeo, thread, post, etc.)
model Output {
  id                   String              @id @default(uuid())
  outputType           OutputType
  format               String              @db.VarChar(50)
  title                String?             @db.VarChar(255)
  duration             Int?
  aspectRatio          String?             @db.VarChar(10)
  platform             String?             @db.VarChar(50)
  targetWPM            Int                 @default(150)
  language             String              @default("pt-BR") @db.VarChar(10)
  narrationLanguage    String              @default("pt-BR") @db.VarChar(10)
  voiceId              String?             @db.VarChar(100)
  enableMotion         Boolean             @default(false)
  objective            String? // Objetivo editorial: diretriz narrativa que governa a geração do roteiro
  mustInclude          String?
  mustExclude          String?
  classificationId     String?             @db.VarChar(50) // Tema/tonalidade (intelligence-classifications). Pai: define script e visual recomendados.
  scriptStyleId        String?
  visualStyleId        String?
  seedId               String?
  status               OutputStatus        @default(PENDING)
  scriptApproved       Boolean             @default(false)
  imagesApproved       Boolean             @default(false)
  bgmApproved          Boolean             @default(false)
  audioApproved        Boolean             @default(false)
  videosApproved       Boolean             @default(false)
  renderApproved       Boolean             @default(false)
  outputData           Bytes?
  outputMimeType       String?             @db.VarChar(50)
  outputSize           Int?
  captionedVideoData   Bytes?
  captionedVideoSize   Int?
  thumbnailPath        String?             @db.VarChar(500)
  thumbnailData        Bytes?
  thumbnailCandidates  Json?
  socialKit            Json? // Kit de publicação: títulos, descrições e hashtags por plataforma
  outputPath           String?             @db.VarChar(500)
  errorMessage         String?
  pipelineLog          Json?
  /// Opções para esta renderização: legendas/logo aplicados no pipeline antes de salvar (uma gravação)
  renderOptions        Json? // { includeLogo?: boolean, includeCaptions?: boolean, captionStyleId?: string | null }
  storyOutline         Json? // Story Architect: plano narrativo estruturado (etapa isolada)
  storyOutlineApproved Boolean             @default(false) // Validação obrigatória antes de gerar roteiro
  createdAt            DateTime            @default(now())
  updatedAt            DateTime            @updatedAt
  completedAt          DateTime?
  dossierId            String
  audioTracks          AudioTrack[]
  relationsFrom        OutputRelation[]    @relation("MainOutput")
  relationsTo          OutputRelation[]    @relation("RelatedOutput")
  dossier              Dossier             @relation(fields: [dossierId], references: [id], onDelete: Cascade)
  seed                 Seed?               @relation("OutputSeed", fields: [seedId], references: [id], onDelete: SetNull)
  executions           PipelineExecution[]
  scenes               Scene[]
  script               Script?
  costLogs             CostLog[]

  @@index([dossierId])
  @@index([classificationId])
  @@index([outputType])
  @@index([platform])
  @@index([status])
  @@index([createdAt])
  @@map("outputs")
}

/// Relação entre outputs (ex: teaser → full)
model OutputRelation {
  id              String   @id @default(uuid())
  mainOutputId    String
  relatedOutputId String
  relationType    String   @db.VarChar(50)
  createdAt       DateTime @default(now())
  mainOutput      Output   @relation("MainOutput", fields: [mainOutputId], references: [id], onDelete: Cascade)
  relatedOutput   Output   @relation("RelatedOutput", fields: [relatedOutputId], references: [id], onDelete: Cascade)

  @@unique([mainOutputId, relatedOutputId])
  @@index([relationType])
  @@map("output_relations")
}

/// Roteiro completo do output
model Script {
  id                    String                 @id @default(uuid())
  outputId              String                 @unique
  summary               String
  fullText              String
  wordCount             Int                    @default(0)
  provider              AIProvider
  modelUsed             String?                @db.VarChar(100)
  promptUsed            String?
  backgroundMusicPrompt String? // Prompt Stable Audio 2.5 para música única (TikTok/Instagram)
  backgroundMusicVolume Float? // Volume em dB para mixagem (-24 a -6)
  createdAt             DateTime               @default(now())
  updatedAt             DateTime               @updatedAt
  output                Output                 @relation(fields: [outputId], references: [id], onDelete: Cascade)
  backgroundMusicTracks BackgroundMusicTrack[] // Lista de tracks com timestamps (YouTube Cinematic)

  @@map("scripts")
}

/// Cena individual do output
model Scene {
  id                     String       @id @default(uuid())
  outputId               String
  order                  Int
  narration              String
  visualDescription      String
  audioDescription       String?
  startTime              Float?
  endTime                Float?
  estimatedDuration      Float        @default(5)
  imageStatus            String       @default("pending") @db.VarChar(20) /// pending | generated | restricted | error
  imageRestrictionReason String? /// Razão da restrição pelo filtro de conteúdo
  createdAt              DateTime     @default(now())
  updatedAt              DateTime     @updatedAt
  images                 SceneImage[]
  videos                 SceneVideo[]
  audioTracks            AudioTrack[]
  output                 Output       @relation(fields: [outputId], references: [id], onDelete: Cascade)

  @@index([outputId])
  @@index([outputId, order])
  @@map("scenes")
}

/// Track de música de fundo por segmento de cenas (para vídeos longos YouTube)
model BackgroundMusicTrack {
  id         String   @id @default(uuid())
  scriptId   String
  prompt     String // Prompt Stable Audio 2.5 (gênero, instrumentos, BPM, mood)
  volume     Float    @default(-18) // Volume em dB para mixagem (-24 a -6)
  startScene Int // Cena onde esta track começa (0 = primeira cena)
  endScene   Int? // Última cena desta track (null = até a última cena)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  script     Script   @relation(fields: [scriptId], references: [id], onDelete: Cascade)

  @@index([scriptId])
  @@map("background_music_tracks")
}

/// Imagem gerada para uma cena
model SceneImage {
  id           String     @id @default(uuid())
  sceneId      String
  provider     AIProvider
  promptUsed   String
  fileData     Bytes?
  mimeType     String?    @db.VarChar(50)
  originalSize Int?
  width        Int?
  height       Int?
  isSelected   Boolean    @default(false)
  variantIndex Int        @default(0)
  createdAt    DateTime   @default(now())
  scene        Scene      @relation(fields: [sceneId], references: [id], onDelete: Cascade)

  @@index([sceneId])
  @@map("scene_images")
}

/// Vídeo/Motion gerado para uma cena
model SceneVideo {
  id            String     @id @default(uuid())
  sceneId       String
  provider      AIProvider
  promptUsed    String?
  fileData      Bytes?
  mimeType      String?    @db.VarChar(50)
  originalSize  Int?
  duration      Float?
  sourceImageId String?
  isSelected    Boolean    @default(false)
  variantIndex  Int        @default(0)
  createdAt     DateTime   @default(now())
  scene         Scene      @relation(fields: [sceneId], references: [id], onDelete: Cascade)

  @@index([sceneId])
  @@map("scene_videos")
}

/// Trilha de áudio gerada
model AudioTrack {
  id           String     @id @default(uuid())
  outputId     String
  sceneId      String?
  type         String     @db.VarChar(50)
  provider     AIProvider
  voiceId      String?    @db.VarChar(100)
  fileData     Bytes?
  mimeType     String?    @db.VarChar(50)
  originalSize Int?
  duration     Float?
  alignment    Json? /// Word-level timestamps do ElevenLabs: [{word, startTime, endTime}]
  createdAt    DateTime   @default(now())
  output       Output     @relation(fields: [outputId], references: [id], onDelete: Cascade)
  scene        Scene?     @relation(fields: [sceneId], references: [id], onDelete: SetNull)

  @@index([outputId])
  @@index([sceneId])
  @@map("audio_tracks")
}

/// Configuração de provedores de IA
model ProviderConfig {
  id                String     @id @default(uuid())
  provider          AIProvider @unique
  apiKey            String     @db.VarChar(500)
  isActive          Boolean    @default(true)
  settings          Json?
  requestsPerMinute Int?
  createdAt         DateTime   @default(now())
  updatedAt         DateTime   @updatedAt

  @@map("provider_configs")
}

/// Logs de execução do pipeline
model PipelineExecution {
  id         String   @id @default(uuid())
  outputId   String
  step       String   @db.VarChar(50)
  status     String   @db.VarChar(20)
  message    String?
  metadata   Json?
  durationMs Int?
  createdAt  DateTime @default(now())
  output     Output   @relation(fields: [outputId], references: [id], onDelete: Cascade)

  @@index([outputId])
  @@index([createdAt])
  @@map("pipeline_executions")
}

/// NOTA: VisualStyle e ScriptStyle foram migrados para constantes em
/// server/constants/visual-styles.ts e server/constants/script-styles.ts
/// Os campos scriptStyleId e visualStyleId agora armazenam slugs de string.

/// Seeds para geração de imagens/vídeos (receitas visuais)
model Seed {
  id                  String    @id @default(uuid())
  value               Int       @unique
  usageCount          Int       @default(0)
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt
  outputs             Output[]  @relation("OutputSeed")
  preferredByDossiers Dossier[] @relation("DossierPreferredSeed")

  @@map("seeds")
}

/// Log de custos de API - append-only ledger desacoplado dos artefatos
/// Cada registro pertence a um output (pipeline de vídeo) OU a um dossier (ex: análise neural).
model CostLog {
  id        String   @id @default(uuid())
  outputId  String? /// null quando o custo é de recurso do dossier (ex: insights)
  dossierId String? /// preenchido para custos no nível do dossier (análise neural)
  resource  String   @db.VarChar(50) /// "outline" | "script" | "image" | "narration" | "bgm" | "motion" | "insights"
  action    String   @db.VarChar(20) /// "create" | "recreate"
  provider  String   @db.VarChar(30) /// "REPLICATE" | "ELEVENLABS" | "OPENAI" | "ANTHROPIC"
  model     String?  @db.VarChar(100) /// ex: "black-forest-labs/flux-schnell"
  cost      Float /// Custo em USD
  metadata  Json? /// Dados de cálculo: predict_time, characters, tokens, etc
  detail    String?  @db.VarChar(255) /// Descrição legível
  createdAt DateTime @default(now())
  output    Output?  @relation(fields: [outputId], references: [id], onDelete: Restrict)
  dossier   Dossier? @relation(fields: [dossierId], references: [id], onDelete: Restrict)

  @@index([outputId])
  @@index([dossierId])
  @@index([resource])
  @@index([createdAt])
  @@map("cost_logs")
}

/// Plano de monetização gerado pela IA (Document-First Strategy)
/// Armazena o JSON completo do plano para exibição posterior sem regenerar.
model MonetizationPlan {
  id                String   @id @default(uuid())
  dossierId         String
  planData          Json /// JSON completo do plano: fullVideo, teasers[], publicationSchedule[], etc.
  teaserDuration    Int /// Duração configurada dos teasers (60, 120 ou 180 segundos)
  fullVideoDuration Int /// Duração configurada do full video (300, 600 ou 900 segundos)
  teaserCount       Int      @default(0) /// Quantidade de teasers no plano
  provider          String   @db.VarChar(30) /// "OPENAI" | "ANTHROPIC"
  model             String?  @db.VarChar(100) /// ex: "claude-sonnet-4-20250514"
  inputTokens       Int      @default(0)
  outputTokens      Int      @default(0)
  cost              Float    @default(0) /// Custo em USD da geração
  isActive          Boolean  @default(true) /// false = substituído por um plano mais novo
  createdAt         DateTime @default(now())
  dossier           Dossier  @relation(fields: [dossierId], references: [id], onDelete: Cascade)

  @@index([dossierId])
  @@index([isActive])
  @@index([createdAt])
  @@map("monetization_plans")
}

/// Tipo de provedor de IA usado
enum AIProvider {
  OPENAI
  ANTHROPIC
  GEMINI
  ELEVENLABS
  MIDJOURNEY
  STABLE_DIFFUSION
  RUNWAY
  REPLICATE
}

/// Tipo de output gerado a partir de um documento
enum OutputType {
  VIDEO_TEASER
  VIDEO_FULL
  TWITTER_THREAD
  LINKEDIN_POST
  INSTAGRAM_POST
  PODCAST_EPISODE
  BLOG_ARTICLE
}

/// Status de geração do output
enum OutputStatus {
  PENDING
  GENERATING
  RENDERED
  COMPLETED
  FAILED
  CANCELLED
}
